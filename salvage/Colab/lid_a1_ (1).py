# -*- coding: utf-8 -*-
"""Lid A1 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18NZBB51OouyvDUSJ7u3TdECNDrLGKHK8
"""



with open("/content/lid1.txt", 'r') as f:
  file_content = f.read()

print(file_content)

"""## Cell 1: Imports and Configuration"""

import numpy as np
from scipy.sparse import spdiags, csr_matrix
from scipy.sparse.linalg import bicgstab, cg
import matplotlib.pyplot as plt
import types

# All parameters are in one place for easy tweaking
config = {
    'grid': { 'Nx': 33, 'Ny': 33, 'Lx': 1.0, 'Ly': 1.0 }, # Changed to 33x33 grid
    'physics': { 'rho': 1.0, 'mu': 0.01, 'U_lid': 1.0 }, # Re = 100
    'solver': { 'alpha_u': 0.7, 'alpha_p': 0.3, 'max_iter': 1000, 'tolerance': 1e-6 }
}

"""## Cell 2: Grid and Visualization Functions"""

def create_grid(cfg):
    grid = types.SimpleNamespace()
    grid.Nx, grid.Ny = cfg['Nx'], cfg['Ny']
    grid.Lx, grid.Ly = cfg['Lx'], cfg['Ly']
    grid.dx, grid.dy = grid.Lx / (grid.Nx - 1), grid.Ly / (grid.Ny - 1)
    grid.n_cells_x, grid.n_cells_y = grid.Nx - 1, grid.Ny - 1
    grid.total_cells = grid.n_cells_x * grid.n_cells_y
    grid.x_cc = np.linspace(grid.dx / 2, grid.Lx - grid.dx / 2, grid.n_cells_x)
    grid.y_cc = np.linspace(grid.dy / 2, grid.Ly - grid.dy / 2, grid.n_cells_y)
    grid.X_cc, grid.Y_cc = np.meshgrid(grid.x_cc, grid.y_cc)
    return grid

def plot_results(u, v, p, grid):
    plt.style.use('default')
    plt.figure(figsize=(12, 5))

    plt.subplot(1, 2, 1)
    plt.title('Velocity Streamlines')
    plt.xlabel('x'); plt.ylabel('y')
    velocity_mag = np.sqrt(u**2 + v**2)
    plt.streamplot(grid.X_cc, grid.Y_cc, u, v, density=1.5, color=velocity_mag, cmap='viridis')
    plt.colorbar(label='Velocity Magnitude')
    plt.xlim(0, grid.Lx); plt.ylim(0, grid.Ly)
    plt.gca().set_aspect('equal', adjustable='box')

    plt.subplot(1, 2, 2)
    plt.title('Pressure Contours')
    plt.xlabel('x'); plt.ylabel('y')
    plt.contourf(grid.X_cc, grid.Y_cc, p, levels=50, cmap='viridis')
    plt.colorbar(label='Pressure')
    plt.xlim(0, grid.Lx); plt.ylim(0, grid.Ly)
    plt.gca().set_aspect('equal', adjustable='box')

    plt.tight_layout()
    plt.show()

"""## Cell 3: The `solve` Function (Core Logic)"""

def solve(grid, config):
    # Unpack parameters
    Nx, Ny = grid.Nx, grid.Ny
    n_cells_x, n_cells_y = grid.n_cells_x, grid.n_cells_y
    total_cells = grid.n_cells_x * grid.n_cells_y
    dx, dy = grid.dx, grid.dy
    rho, mu, U_lid = config['physics']['rho'], config['physics']['mu'], config['physics']['U_lid']
    alpha_u, alpha_p = config['solver']['alpha_u'], config['solver']['alpha_p']
    max_iter = config['solver']['max_iter']
    tol = config['solver']['tolerance']

    # Initialize fields
    u = np.zeros((n_cells_y, n_cells_x))
    v = np.zeros((n_cells_y, n_cells_x))
    p = np.zeros((n_cells_y, n_cells_x))
    p_prime = np.zeros_like(p)

    for i in range(max_iter):
        # --- Store old values for residual calculation ---
        u_old, v_old = u.copy(), v.copy()

        # --- U-Momentum Predictor ---
        # 1. Convection and Diffusion coefficients (Hybrid Scheme)
        # Calculate face velocities (at cell faces)
        u_e_face = 0.5 * (u[:, :-1] + u[:, 1:])
        u_w_face = 0.5 * (u[:, :-1] + u[:, 1:]) # Placeholder, needs proper boundary handling
        u_n_face = 0.5 * (u[:-1, :] + u[1:, :])
        u_s_face = 0.5 * (u[:-1, :] + u[1:, :]) # Placeholder, needs proper boundary handling


        v_n_face = 0.5 * (v[:-1, :] + v[1:, :])
        v_s_face = 0.5 * (v[:-1, :] + v[1:, :]) # Placeholder, needs proper boundary handling
        v_e_face = 0.5 * (v[:, :-1] + v[:, 1:])
        v_w_face = 0.5 * (v[:, :-1] + v[:, 1:]) # Placeholder, needs proper calculation at boundary


        # Apply U-velocity boundary conditions at faces
        u_e_face_bc = np.zeros((n_cells_y, n_cells_x + 1))
        u_e_face_bc[:, 1:-1] = u_e_face
        u_e_face_bc[:, -1] = U_lid # Lid boundary condition

        u_w_face_bc = np.zeros((n_cells_y, n_cells_x + 1))
        u_w_face_bc[:, 1:-1] = u_w_face # Needs proper calculation at boundary

        u_n_face_bc = np.zeros((n_cells_y + 1, n_cells_x))
        u_n_face_bc[1:-1, :] = u_n_face

        u_s_face_bc = np.zeros((n_cells_y + 1, n_cells_x))
        u_s_face_bc[1:-1, :] = u_s_face # Needs proper calculation at boundary


        # Apply V-velocity boundary conditions at faces
        v_n_face_bc = np.zeros((n_cells_y + 1, n_cells_x))
        v_n_face_bc[1:-1, :] = v_n_face

        v_s_face_bc = np.zeros((n_cells_y + 1, n_cells_x))
        v_s_face_bc[1:-1, :] = v_s_face # Needs proper calculation at boundary

        v_e_face_bc = np.zeros((n_cells_y, n_cells_x + 1))
        v_e_face_bc[:, 1:-1] = v_e_face

        v_w_face_bc = np.zeros((n_cells_y, n_cells_x + 1))
        v_w_face_bc[:, 1:-1] = v_w_face # Needs proper calculation at boundary


        Pe_e = (rho * u_e_face_bc[:, :-1] * dy) / mu
        Pe_w = (rho * u_w_face_bc[:, 1:] * dy) / mu
        Pe_n = (rho * v_n_face_bc[:-1, :] * dx) / mu
        Pe_s = (rho * v_s_face_bc[1:, :] * dx) / mu


        F_e = rho * u_e_face_bc[:, :-1] * dy
        F_w = rho * u_w_face_bc[:, 1:] * dy
        F_n = rho * v_n_face_bc[:-1, :] * dx
        F_s = rho * v_s_face_bc[1:, :] * dx


        D_e = mu * dy / dx
        D_w = mu * dy / dx
        D_n = mu * dx / dy
        D_s = mu * dx / dy


        # Calculate a coefficients at cell centers
        a_E_u = np.maximum(0, -F_e) + np.maximum(0, D_e - F_e/2) # Using Hybrid scheme directly
        a_W_u = np.maximum(0, F_w) + np.maximum(0, D_w + F_w/2)
        a_N_u = np.maximum(0, -F_n) + np.maximum(0, D_n - F_n/2)
        a_S_u = np.maximum(0, F_s) + np.maximum(0, D_s + F_s/2)


        # 2. Pressure Gradient Source Term
        S_p_u = np.zeros((n_cells_y, n_cells_x))
        S_p_u[:, :-1] = -(p[:, 1:] - p[:, :-1]) * dy


        # 3. Boundary Conditions for a_P_u
        a_P_u = a_E_u + a_W_u + a_N_u + a_S_u

        # Apply source terms for boundary conditions
        a_P_u[0, :] += 2 * D_s # Bottom wall (No-slip)
        a_P_u[-1, :] += 2 * D_n; S_p_u[-1, :] += 2 * D_n * U_lid # Top wall (Lid)
        a_P_u[:, 0] += 2 * D_w # West wall (No-slip)
        a_P_u[:, -1] += 2 * D_e # East wall (No-slip)


        # 4. Solve for u_star
        # Construct matrix A_u
        main_diag_u = a_P_u.flatten()
        lower_diag_u = -a_S_u[1:, :].flatten()
        upper_diag_u = -a_N_u[:-1, :].flatten()
        left_diag_u = -a_W_u[:, 1:].flatten()
        right_diag_u = -a_E_u[:, :-1].flatten()


        A_u = spdiags([lower_diag_u, left_diag_u, main_diag_u, right_diag_u, upper_diag_u],
                      [-n_cells_x, -1, 0, 1, n_cells_x], total_cells, total_cells, format='csr')

        u_flat, _ = bicgstab(A_u, S_p_u.flatten())
        u = u_flat.reshape((n_cells_y, n_cells_x))


        # --- V-Momentum Predictor (similar steps) ---
        # Calculate a coefficients at cell centers
        a_E_v = np.maximum(0, -F_e) + np.maximum(0, D_e - F_e/2)
        a_W_v = np.maximum(0, F_w) + np.maximum(0, D_w + F_w/2)
        a_N_v = np.maximum(0, -F_n) + np.maximum(0, D_n - F_n/2)
        a_S_v = np.maximum(0, F_s) + np.maximum(0, D_s + F_s/2)


        S_p_v = np.zeros((n_cells_y, n_cells_x))
        S_p_v[:-1, :] = -(p[1:, :] - p[:-1, :]) * dx


        # Calculate a_P_v
        a_P_v = a_E_v + a_W_v + a_N_v + a_S_v

        # Apply boundary conditions to a_P_v
        a_P_v[0, : ] += 2 * D_s; a_P_v[-1, :] += 2 * D_n
        a_P_v[:, 0] += 2 * D_w; a_P_v[:, -1] += 2 * D_e


        # Construct matrix A_v
        main_diag_v = a_P_v.flatten()
        lower_diag_v = -a_S_v[1:, :].flatten()
        upper_diag_v = -a_N_v[:-1, :].flatten()
        left_diag_v = -a_W_v[:, 1:].flatten()
        right_diag_v = -a_E_v[:, :-1].flatten()


        A_v = spdiags([lower_diag_v, left_diag_v, main_diag_v, right_diag_v, upper_diag_v],
                      [-n_cells_x, -1, 0, 1, n_cells_x], total_cells, total_cells, format='csr')

        v_flat, _ = bicgstab(A_v, S_p_v.flatten())
        v = v_flat.reshape((n_cells_y, n_cells_x))


        # --- Pressure Correction ---
        d_u = dy / a_P_u # Use boundary conditioned a_P_u
        d_v = dx / a_P_v # Use boundary conditioned a_P_v

        a_E_p = rho * d_u[:, :-1] * dy
        a_W_p = rho * d_u[:, 1:] * dy
        a_N_p = rho * d_v[:-1, :] * dx
        a_S_p = rho * d_v[1:, :] * dx
        a_P_p = a_E_p + a_W_p + a_N_p + a_S_p

        b_p_flat = ((rho * (u[:,:-1] - u[:,1:]) * dy) + (rho * (v[:-1,:] - v[1:,:]) * dx)).flatten()
        b_p_flat[0] = 0

        Ap = spdiags([-a_S_p.flatten(), -a_W_p.flatten(), a_P_p.flatten(), a_E_p.flatten(), a_N_p.flatten()],
                     [-n_cells_x, -1, 0, 1, n_cells_x], total_cells, total_cells, format='csr')
        Ap.data[Ap.indptr[0]:Ap.indptr[1]] = 0; Ap[0,0] = 1

        p_prime.flat, _ = cg(Ap, b_p_flat)
        p += alpha_p * p_prime

        # --- Velocity Correction ---
        u[:, 1:-1] += alpha_u * 0.5 * (d_u[:, 1:-1] + d_u[:, :-2]) * (p_prime[:, 1:-1] - p_prime[:, 2:])
        v[1:-1, :] += alpha_u * 0.5 * (d_v[1:-1, :] + d_v[:-2, :]) * (p_prime[1:-1, :] - p_prime[2:, :])

        # --- Check for Convergence ---
        res = np.linalg.norm(u - u_old) + np.linalg.norm(v - v_old)
        print(f"Iter: {i+1:>4} | Residual: {res:<10.3e}")
        if res < tol:
            print("Converged!")
            break

    return u, v, p

"""## Cell 4: Main Execution"""

if __name__ == '__main__':
    grid = create_grid(config['grid'])
    u_final, v_final, p_final = solve(grid, config)
    plot_results(u_final, v_final, p_final, grid)

with open("/content/lid2.txt", 'r') as f:
  test_content = f.read()

print(test_content)

with open("/content/lid3.txt", 'r') as f:
  lid3_content = f.read()

print(lid3_content)

with open("/content/lid3.txt", 'r') as f:
  lid3_content = f.read()

print(lid3_content)

with open("/content/lid3.txt", 'r') as f:
  lid3_content = f.read()

print(lid3_content)

import numpy as np
from scipy.sparse import spdiags, csr_matrix
from scipy.sparse.linalg import bicgstab, cg
import matplotlib.pyplot as plt
import types

# Cell 1: Configuration
config = {
    'grid': { 'Nx': 65, 'Ny': 65, 'Lx': 1.0, 'Ly': 1.0 },
    'physics': { 'rho': 1.0, 'mu': 0.01, 'U_lid': 1.0 }, # Re = 100
    'solver': { 'alpha_u': 0.7, 'alpha_p': 0.3, 'max_iter': 2000, 'tolerance': 1e-6 }
}

# Cell 2: Grid and Visualization Functions
def create_grid(cfg):
    grid = types.SimpleNamespace()
    grid.Nx, grid.Ny = cfg['Nx'], cfg['Ny']
    grid.Lx, grid.Ly = cfg['Lx'], cfg['Ly']
    grid.dx, grid.dy = grid.Lx / (grid.Nx - 1), grid.Ly / (grid.Ny - 1)
    grid.n_cells_x, grid.n_cells_y = grid.Nx - 1, grid.Ny - 1
    grid.total_cells = grid.n_cells_x * grid.n_cells_y
    grid.x_cc = np.linspace(grid.dx / 2, grid.Lx - grid.dx / 2, grid.n_cells_x)
    grid.y_cc = np.linspace(grid.dy / 2, grid.Ly - grid.dy / 2, grid.n_cells_y)
    grid.X_cc, grid.Y_cc = np.meshgrid(grid.x_cc, grid.y_cc)
    print(f"Grid created: {grid.n_cells_x}x{grid.n_cells_y} cells.")
    return grid

def plot_results(u, v, p, grid):
    plt.style.use('default')
    velocity_mag = np.sqrt(u**2 + v**2)
    plt.figure(figsize=(12, 5))

    plt.subplot(1, 2, 1)
    plt.title('Velocity Streamlines')
    plt.xlabel('x'); plt.ylabel('y')
    plt.streamplot(grid.X_cc, grid.Y_cc, u, v, density=1.5, color=velocity_mag, cmap='viridis')
    plt.colorbar(label='Velocity Magnitude')
    plt.xlim(0, grid.Lx); plt.ylim(0, grid.Ly)
    plt.gca().set_aspect('equal', adjustable='box')

    plt.subplot(1, 2, 2)
    plt.title('Pressure Contours')
    plt.xlabel('x'); plt.ylabel('y')
    plt.contourf(grid.X_cc, grid.Y_cc, p, levels=50, cmap='viridis')
    plt.colorbar(label='Pressure')
    plt.xlim(0, grid.Lx); plt.ylim(0, grid.Ly)
    plt.gca().set_aspect('equal', adjustable='box')

    plt.tight_layout()
    plt.show()

# This is the provided function from your file
def calculate_continuity_residual(u_star, v_star, grid, config):
    rho = config['physics']['rho']
    u_face_e = 0.5 * (u_star[:, :-1] + u_star[:, 1:])
    u_face_w = 0.5 * (np.hstack([np.zeros((grid.n_cells_y, 1)), u_star[:, :-1]]) + u_star)
    v_face_n = 0.5 * (v_star[:-1, :] + v_star[1:, :])
    v_face_s = 0.5 * (np.vstack([np.zeros((1, grid.n_cells_x)), v_star[:-1, :]]) + v_star)

    b_p = rho * (u_face_w - u_face_e) * grid.dy + rho * (v_face_s - v_face_n) * grid.dx
    return b_p

# MISSING CORE SOLVER LOGIC (Provided below)
def solve(grid, config):
    # Unpack parameters
    n_cells_x, n_cells_y = grid.n_cells_x, grid.n_cells_y
    total_cells = grid.total_cells
    dx, dy = grid.dx, grid.dy
    rho, mu, U_lid = config['physics']['rho'], config['physics']['mu'], config['physics']['U_lid']
    alpha_u, alpha_p = config['solver']['alpha_u'], config['solver']['alpha_p']
    max_iter, tol = config['solver']['max_iter'], config['solver']['tolerance']

    # Initialize fields
    u = np.zeros((n_cells_y, n_cells_x))
    v = np.zeros((n_cells_y, n_cells_x))
    p = np.zeros((n_cells_y, n_cells_x))

    print("--- Starting SIMPLE Algorithm ---")
    for i in range(max_iter):
        u_old = u.copy()

        # --- U-Momentum Predictor ---
        # Diffusion coefficients at cell faces (these should have face dimensions)
        D_e_face = mu * dy / dx * np.ones((n_cells_y, n_cells_x + 1))
        D_w_face = mu * dy / dx * np.ones((n_cells_y, n_cells_x + 1))
        D_n_face = mu * dx / dy * np.ones((n_cells_y + 1, n_cells_x))
        D_s_face = mu * dx / dy * np.ones((n_cells_y + 1, n_cells_x))


        u_e_face = 0.5 * (u[:, :-1] + u[:, 1:])
        v_n_face = 0.5 * (v[:-1, :] + v[1:, :])

        F_e = rho * u_e_face * dy
        F_n = rho * v_n_face * dx

        # Calculate a coefficients with correct dimensions (n_cells_y, n_cells_x)
        a_E = np.zeros((n_cells_y, n_cells_x))
        a_W = np.zeros((n_cells_y, n_cells_x))
        a_N = np.zeros((n_cells_y, n_cells_x))
        a_S = np.zeros((n_cells_y, n_cells_x))

        # Use diffusion coefficients at cell centers for a_P calculation
        D_e = mu * dy / dx
        D_w = mu * dy / dx
        D_n = mu * dx / dy
        D_s = mu * dx / dy


        a_E[:, :-1] = D_e_face[:, 1:-1] - 0.5 * F_e # Corrected slicing for D_e_face
        a_W[:, 1:] = D_w_face[:, :-1] + 0.5 * F_e[:, :-1] # Corrected slicing for D_w_face and F_e
        a_N[:-1, :] = D_n_face[1:-1, :] - 0.5 * F_n[:-1, :] # Corrected slicing for D_n_face
        a_S[1:, :] = D_s_face[:-1, :] + 0.5 * F_n[1:, :] # Corrected slicing for D_s_face


        S_p_u = (p[:,:-1] - p[:,1:]) * dy
        a_P_u = a_E + a_W + a_N + a_S
        a_P_u[:, 0] += D_w; a_P_u[:, -1] += D_e
        a_P_u[0, :] += D_s; a_P_u[-1, :] += D_n
        S_p_u[-1,:] += 2 * D_n * U_lid

        A_u = spdiags([-a_S.flatten(), -a_W.flatten(), a_P_u.flatten(), a_E.flatten(), a_N.flatten()],
                      [-n_cells_x, -1, 0, 1, n_cells_x], total_cells, total_cells, format='csr')
        u_star = u.copy()
        u_star.flat, _ = bicgstab(A_u, S_p_u.flatten(), x0=u.flatten(), tol=1e-8)

        # --- V-Momentum Predictor ---
        # Calculate a coefficients with correct dimensions (n_cells_y, n_cells_x)
        a_E_v = np.zeros((n_cells_y, n_cells_x))
        a_W_v = np.zeros((n_cells_y, n_cells_x))
        a_N_v = np.zeros((n_cells_y, n_cells_x))
        a_S_v = np.zeros((n_cells_y, n_cells_x))

        a_E_v[:-1, :] = D_e_face[:-1, 1:-1] - 0.5 * F_e[:-1, :] # Corrected slicing
        a_W_v[1:, :] = D_e_face[1:, :-1] + 0.5 * F_e[1:, :-1] # Corrected slicing
        a_N_v[:, :-1] = D_n_face[:, 1:-1] - 0.5 * F_n[:, :-1] # Corrected slicing
        a_S_v[:, 1:] = D_n_face[:, :-1] + 0.5 * F_n[:, 1:] # Corrected slicing


        S_p_v = np.zeros((n_cells_y, n_cells_x))
        S_p_v[:-1, :] = -(p[1:, :] - p[:-1, :]) * dx

        a_P_v = a_E_v + a_W_v + a_N_v + a_S_v
        a_P_v[:, 0] += D_w; a_P_v[:, -1] += D_e
        a_P_v[0, :] += D_s; a_P_v[-1, :] += D_n
        S_p_v = (p[:-1,:] - p[1:,:]) * dx # Recalculate S_p_v after boundary conditions

        A_v = spdiags([-a_S_v.flatten(), -a_W_v.flatten(), a_P_v.flatten(), a_E_v.flatten(), a_N_v.flatten()],
                      [-n_cells_x, -1, 0, 1, n_cells_x], total_cells, total_cells, format='csr')
        v_star = v.copy()
        v_star.flat, _ = bicgstab(A_v, S_p_v.flatten(), x0=v.flatten(), tol=1e-8)

        # --- Pressure Correction ---
        d_u = dy / a_P_u
        d_v = dx / a_P_v
        a_E_p = rho * d_u[:,:-1] * dy; a_W_p = rho * d_u[:,1:] * dy
        a_N_p = rho * d_v[:-1,:] * dx; a_S_p = rho * d_v[1:,:] * dx
        a_P_p = a_E_p + a_W_p + a_N_p + a_S_p

        b_p = calculate_continuity_residual(u_star, v_star, grid, config)
        b_p_flat = b_p.flatten()
        b_p_flat[0] = 0.0

        Ap = spdiags([-a_S_p.flatten(), -a_W_p.flatten(), a_P_p.flatten(), a_E_p.flatten(), a_N_p.flatten()],
                     [-n_cells_x, -1, 0, 1, n_cells_x], total_cells, total_cells, format='csr')
        Ap.data[Ap.indptr[0]:Ap.indptr[1]] = 0; Ap[0,0] = 1.0

        p_prime_flat, _ = cg(Ap, b_p_flat, tol=1e-8)
        p_prime = p_prime_flat.reshape(n_cells_y, n_cells_x)

        # --- Field Correction ---
        p += alpha_p * p_prime
        u += alpha_u * d_u * (p_prime[:,:-1] - p_prime[:,1:])
        v += alpha_u * d_v * (p_prime[:-1,:] - p_prime[1:,:])

        # --- Enforce BCs ---
        u[0, :], u[-1, :], u[:, 0], u[:, -1] = 0.0, U_lid, 0.0, 0.0
        v[0, :], v[-1, :], v[:, 0], v[:, -1] = 0.0, 0.0, 0.0, 0.0

        # --- Check for Convergence ---
        res = np.linalg.norm(u - u_old)
        print(f"Iter: {i+1:>4} | U-Field Change: {res:<10.3e}")
        if res < tol:
            print("Converged!")
            break

    return u, v, p

# --- Main Execution Block ---
grid = create_grid(config['grid'])
u_final, v_final, p_final = solve(grid, config)
plot_results(u_final, v_final, p_final, grid)

with open("/content/lid 4.txt", 'r') as f:
  lid4_content = f.read()

print(lid4_content)

import numpy as np
import matplotlib.pyplot as plt
import time

# ==============================================================================
# 1. CONFIGURATION
# ==============================================================================
# All parameters are in one place for easy tweaking.
# Grid and physical parameters for Reynolds Number (Re) = 100
# Re = rho * U * L / mu => 1.0 * 1.0 * 1.0 / 0.01 = 100
config = {
    'grid': {
        'Nx': 41,  # Number of nodes in x-direction
        'Ny': 41,  # Number of nodes in y-direction
        'Lx': 1.0, # Domain length in x
        'Ly': 1.0  # Domain length in y
    },
    'physics': {
        'rho': 1.0,   # Density
        'mu': 0.01,   # Dynamic viscosity
        'U_lid': 1.0  # Lid velocity
    },
    'solver': {
        'alpha_u': 0.7,  # Under-relaxation for velocity
        'alpha_p': 0.3,  # Under-relaxation for pressure
        'max_iter': 1000, # Maximum iterations for the SIMPLE loop
        'tolerance': 1e-6 # Convergence tolerance for residuals
    }
}

# ==============================================================================
# 2. GRID AND VISUALIZATION FUNCTIONS
# ==============================================================================

def create_staggered_grid(cfg):
    """Creates a structured, staggered grid."""
    grid_cfg = cfg['grid']
    grid = {
        'Nx': grid_cfg['Nx'], 'Ny': grid_cfg['Ny'],
        'Lx': grid_cfg['Lx'], 'Ly': grid_cfg['Ly']
    }
    # Cell dimensions
    grid['dx'] = grid['Lx'] / (grid['Nx'] - 1)
    grid['dy'] = grid['Ly'] / (grid['Ny'] - 1)

    # Pressure nodes (cell centers)
    grid['x_p'] = np.linspace(grid['dx']/2, grid['Lx'] - grid['dx']/2, grid['Nx'] - 1)
    grid['y_p'] = np.linspace(grid['dy']/2, grid['Ly'] - grid['dy']/2, grid['Ny'] - 1)

    # U-velocity nodes (vertical faces)
    grid['x_u'] = np.linspace(0, grid['Lx'], grid['Nx'])
    grid['y_u'] = np.linspace(grid['dy']/2, grid['Ly'] - grid['dy']/2, grid['Ny'] - 1)

    # V-velocity nodes (horizontal faces)
    grid['x_v'] = np.linspace(grid['dx']/2, grid['Lx'] - grid['dx']/2, grid['Nx'] - 1)
    grid['y_v'] = np.linspace(0, grid['Ly'], grid['Ny'])

    print(f"Grid created: {grid['Nx']-1}x{grid['Ny']-1} cells.")
    return grid

def plot_results(u, v, p, grid, title="Converged Solution"):
    """Visualizes the final flow field."""
    # Interpolate velocities to cell centers for visualization
    u_c = 0.5 * (u[:, :-1] + u[:, 1:])
    v_c = 0.5 * (v[:-1, :] + v[1:, :])

    X_p, Y_p = np.meshgrid(grid['x_p'], grid['y_p'])

    plt.style.use('default')
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    fig.suptitle(title, fontsize=16)

    # Velocity Streamlines
    velocity_mag = np.sqrt(u_c**2 + v_c**2)
    strm = ax1.streamplot(X_p, Y_p, u_c, v_c, color=velocity_mag, cmap='viridis', density=1.5)
    fig.colorbar(strm.lines, ax=ax1, label='Velocity Magnitude')
    ax1.set_title('Velocity Streamlines')
    ax1.set_xlabel('x')
    ax1.set_ylabel('y')
    ax1.set_xlim(0, grid['Lx'])
    ax1.set_ylim(0, grid['Ly'])
    ax1.set_aspect('equal', adjustable='box')

    # Pressure Contours
    contour = ax2.contourf(X_p, Y_p, p, levels=50, cmap='viridis')
    fig.colorbar(contour, ax=ax2, label='Pressure')
    ax2.set_title('Pressure Contours')
    ax2.set_xlabel('x')
    ax2.set_ylabel('y')
    ax2.set_xlim(0, grid['Lx'])
    ax2.set_ylim(0, grid['Ly'])
    ax2.set_aspect('equal', adjustable='box')

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()

# ==============================================================================
# 3. CORE SOLVER (SIMPLE ALGORITHM ON A STAGGERED GRID)
# ==============================================================================

def solve_lid_driven_cavity(grid, cfg):
    """
    Solves the 2D incompressible Navier-Stokes equations for a lid-driven cavity
    using the SIMPLE algorithm on a staggered grid.
    """
    # --- Unpack Parameters ---
    Nx, Ny = grid['Nx'], grid['Ny']
    dx, dy = grid['dx'], grid['dy']
    rho, mu, U_lid = cfg['physics']['rho'], cfg['physics']['mu'], cfg['physics']['U_lid']
    alpha_u, alpha_p = cfg['solver']['alpha_u'], cfg['solver']['alpha_p']
    max_iter = cfg['solver']['max_iter']
    tol = cfg['solver']['tolerance']

    # --- Initialize Fields ---
    # Staggered grid fields
    u = np.zeros((Ny - 1, Nx))  # U-velocity on vertical faces
    v = np.zeros((Ny, Nx - 1))  # V-velocity on horizontal faces
    p = np.zeros((Ny - 1, Nx - 1)) # Pressure at cell centers

    print("--- Starting SIMPLE Algorithm ---")
    start_time = time.time()

    for it in range(max_iter):
        # --- 1. Solve Momentum Predictor (for u* and v*) ---
        # Store old values for residual calculation
        u_old = u.copy()

        # Assemble u-momentum matrix (A_u * u = b_u)
        # Diffusion coefficients for U-momentum (at U-cell faces)
        # U-cells are (Ny-1, Nx-1) in size, centered at (Ny-1, Nx) U-nodes
        # East face of U-cell (i,j) is at U-node (i,j+1)
        # West face of U-cell (i,j) is at U-node (i,j)
        # North face of U-cell (i,j) is at V-node (i+1, j)
        # South face of U-cell (i,j) is at V-node (i, j)

        D_u_dx = mu * dy / dx # Diffusion term related to dx (constant)
        D_v_dy = mu * dx / dy # Diffusion term related to dy (constant)


        u_p_at_u_nodes = 0.5 * (u[:, :-1] + u[:, 1:]) # (Ny-1, Nx-1)
        # Corrected calculation for v_avg_at_u_nodes
        # Average v at the center of the top face of U-cell (i,j) -> at V-node (i+1, j)
        # Average v at the center of the bottom face of U-cell (i,j) -> at V-node (i, j)
        v_avg_at_u_nodes = 0.5 * (v[1:, :-1] + v[:-1, :-1]) # Corrected slicing for v, should have shape (Ny-1, Nx-1)


        F_e_u = rho * u_p_at_u_nodes * dy # (Ny-1, Nx-1)
        F_w_u = rho * u_p_at_u_nodes * dy # Needs proper boundary handling and slicing
        F_n_u = rho * v_avg_at_u_nodes * dx # (Ny-1, Nx-1)
        F_s_u = rho * v_avg_at_u_nodes * dx # (Ny-1, Nx-1)


        # Calculate a coefficients at U-cell centers (Ny-1, Nx-1)
        a_E_u = D_u_dx * np.ones((Ny-1, Nx-1)) - 0.5 * F_e_u
        a_W_u = D_u_dx * np.ones((Ny-1, Nx-1)) + 0.5 * F_w_u
        a_N_u = D_v_dy * np.ones((Ny-1, Nx-1)) - 0.5 * F_n_u
        a_S_u = D_v_dy * np.ones((Ny-1, Nx-1)) + 0.5 * F_s_u

        a_P_u = a_E_u + a_W_u + a_N_u + a_S_u


        # Pressure source term for u-momentum (Ny-1, Nx-1)
        b_u = (p[:, :-1] - p[:, 1:]) * dy


        # Apply boundary conditions for u-momentum
        # Diffusion terms at boundaries should be 2*D
        a_P_u[:, 0] += 2 * mu * dy / dx # West wall
        a_P_u[:, -1] += 2 * mu * dy / dx # East wall
        a_P_u[0, :] += 2 * mu * dx / dy # Bottom wall
        a_P_u[-1, :] += 2 * mu * dx / dy # Top lid
        b_u[-1, :] += 2 * mu * dx / dy * U_lid # Top lid source term


        # Solve for u*
        u_star = u.copy()
        # Solving for interior points (1:-1 in both dimensions for u)
        # Indices for a coefficients and b_u should align with the u_star indices
        u_star[1:-1, 1:-1] = (1 - alpha_u) * u[1:-1, 1:-1] + \
                           (alpha_u / a_P_u[1:-1, 1:-1]) * \
                           (a_E_u[1:-1, 1:-1] * u[1:-1, 2:] + a_W_u[1:-1, 1:-1] * u[1:-1, :-2] + \
                            a_N_u[1:-1, 1:-1] * u[2:, 1:-1] + a_S_u[1:-1, 1:-1] * u[:-2, 1:-1] + \
                            b_u[1:-1, 1:-1])

        # --- Solve v-momentum predictor (similar to u) ---
        # Diffusion coefficients for V-momentum (at V-cell faces)
        # V-cells are (Ny-1, Nx-1) in size, centered at (Ny, Nx-1) V-nodes
        # East face of V-cell (i,j) is at U-node (i,j+1)
        # West face of V-cell (i,j) is at U-node (i,j)
        # North face of V-cell (i,j) is at V-node (i+1, j)
        # South face of V-cell (i,j) is at V-node (i, j)

        D_u_v = mu * dy / dx # Diffusion term related to dx (constant)
        D_v_v = mu * dx / dy # Diffusion term related to dy (constant)


        v_p_at_v_nodes = 0.5 * (v[:-1, :] + v[1:, :]) # (Ny-1, Nx-1)
        # Corrected calculation for u_avg_at_v_nodes
        # Average u at the center of the east face of V-cell (i,j) -> at U-node (i, j+1)
        # Average u at the center of the west face of V-cell (i,j) -> at U-node (i, j)
        u_avg_at_v_nodes = 0.5 * (u[1:, 1:] + u[1:, :-1]) # Corrected slicing for u, should have shape (Ny-1, Nx-1)


        F_e_v = rho * u_avg_at_v_nodes * dy # (Ny-1, Nx-1)
        F_w_v = rho * u_avg_at_v_nodes * dy # Needs proper boundary handling and slicing
        F_n_v = rho * v_p_at_v_nodes * dx # (Ny-1, Nx-1)
        F_s_v = rho * v_p_at_v_nodes * dx # (Ny-1, Nx-1)


        # Calculate a coefficients at V-cell centers (Ny-1, Nx-1)
        a_E_v = D_u_v * np.ones((Ny-1, Nx-1)) - 0.5 * F_e_v
        a_W_v = D_u_v * np.ones((Ny-1, Nx-1)) + 0.5 * F_w_v
        a_N_v = D_v_v * np.ones((Ny-1, Nx-1)) - 0.5 * F_n_v
        a_S_v = D_v_v * np.ones((Ny-1, Nx-1)) + 0.5 * F_s_v

        a_P_v = a_E_v + a_W_v + a_N_v + a_S_v


        b_v = (p[:-1, :] - p[1:, :]) * dx # (Ny-1, Nx-1)


        # Apply boundary conditions for v-momentum
        a_P_v[:, 0] += 2 * mu * dy / dx # West wall
        a_P_v[:, -1] += 2 * mu * dy / dx # East wall
        a_P_v[0, :] += 2 * mu * dx / dy # Bottom wall
        a_P_v[-1, :] += 2 * mu * dx / dy # Top lid


        v_star = v.copy()
        # Solving for interior points (1:-1 in both dimensions for v)
        # Indices for a coefficients and b_v should align with the v_star indices
        v_star[1:-1, 1:-1] = (1 - alpha_u) * v[1:-1, 1:-1] + \
                           (alpha_u / a_P_v[1:-1, 1:-1]) * \
                           (a_E_v[1:-1, 1:-1] * v[1:-1, 2:] + a_W_v[1:-1, 1:-1] * v[1:-1, :-2] + \
                            a_N_v[1:-1, 1:-1] * v[2:, 1:-1] + a_S_v[1:-1, 1:-1] * v[:-2, 1:-1] + \
                            b_v[1:-1, 1:-1])


        # --- 2. Solve Pressure Correction ---
        # Pressure coefficient dimensions are (Ny-1, Nx-1)
        # d_u and d_v relate pressure gradient to velocity correction
        # d_u is at U-nodes (Ny-1, Nx), d_v is at V-nodes (Ny, Nx-1)
        # d_u is calculated at U-nodes (Ny-1, Nx)
        # Correctly calculate d_u and d_v to have dimensions (Ny-1, Nx) and (Ny, Nx-1) respectively
        d_u = alpha_u * dy / np.hstack([a_P_u, a_P_u[:, -1:]])
        d_v = alpha_u * dx / np.vstack([a_P_v, a_P_v[-1:, :]])


        # Pressure correction coefficients are at cell centers (Ny-1, Nx-1)
        a_E_p = rho * d_u[:, 1:] * dy
        a_W_p = rho * d_u[:, :-1] * dy
        a_N_p = rho * d_v[1:, :] * dx
        a_S_p = rho * d_v[:-1, :] * dx

        a_P_p = a_E_p + a_W_p + a_N_p + a_S_p


        # Mass imbalance (continuity residual) - at cell centers (Ny-1, Nx-1)
        b_p = rho * (u_star[:, :-1] - u_star[:, 1:]) * dy + \
              rho * (v_star[:-1, :] - v_star[1:, :]) * dx

        # Solve for p' (at cell centers, Ny-1, Nx-1)
        p_prime = np.zeros_like(p)
        # Simple Gauss-Seidel for p'
        # Solving for interior points (1:-1 in both dimensions for p')
        for _ in range(50): # Inner iterations
            p_prime_old = p_prime.copy()
            p_prime[1:-1, 1:-1] = (1 / a_P_p[1:-1, 1:-1]) * \
                                 (a_E_p[1:-1, 1:-1] * p_prime[1:-1, 2:] + \
                                  a_W_p[1:-1, 1:-1] * p_prime[1:-1, :-2] + \
                                  a_N_p[1:-1, 1:-1] * p_prime[2:, 1:-1] + \
                                  a_S_p[1:-1, 1:-1] * p_prime[:-2, 1:-1] + \
                                  b_p[1:-1, 1:-1])

        # --- 3. Correct Fields ---
        p += alpha_p * p_prime

        # Velocity corrections are at U-nodes (Ny-1, Nx) and V-nodes (Ny, Nx-1)
        # Need to broadcast p_prime gradient to the dimensions of u and v
        u[:, 1:-1] += d_u[:, 1:-1] * (p_prime[:, :-1] - p_prime[:, 1:]) # Corrected slicing
        v[1:-1, :] += d_v[1:-1, :] * (p_prime[:-1, :] - p_prime[1:, :]) # Corrected slicing


        # --- 4. Enforce Boundary Conditions ---
        u[0, :], u[-1, :], u[:, 0], u[:, -1] = 0.0, U_lid, 0.0, 0.0
        v[0, :], v[-1, :], v[:, 0], v[:, -1] = 0.0, 0.0, 0.0, 0.0

        # --- 5. Check for Convergence ---
        residual = np.linalg.norm(u - u_old) / np.linalg.norm(u) # Using U-velocity change as residual
        if it % 50 == 0:
            print(f"Iter: {it+1:>4} | U-Field Change: {residual:<10.3e}")
        if residual < tol:
            print(f"Converged after {it+1} iterations!")
            break

    if it == max_iter - 1:
        print("Maximum iterations reached without convergence.")

    end_time = time.time()
    print(f"--- Solver Finished in {end_time - start_time:.2f} seconds ---")
    return u, v, p

# ==============================================================================
# 4. MAIN EXECUTION BLOCK
# ==============================================================================
if __name__ == '__main__':
    # Create the grid and run the solver
    grid = create_staggered_grid(config)
    u_final, v_final, p_final = solve_lid_driven_cavity(grid, config)

    # Visualize the results
    plot_results(u_final, v_final, p_final, grid, title=f"Lid-Driven Cavity (Re=100) on a {grid['Nx']-1}x{grid['Ny']-1} Grid")